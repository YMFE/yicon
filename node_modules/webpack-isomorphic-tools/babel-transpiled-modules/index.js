'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _setImmediate2 = require('babel-runtime/core-js/set-immediate');

var _setImmediate3 = _interopRequireDefault(_setImmediate2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _path2 = require('path');

var _path3 = _interopRequireDefault(_path2);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _requireHacker = require('require-hacker');

var _requireHacker2 = _interopRequireDefault(_requireHacker);

var _uglifyJs = require('uglify-js');

var _uglifyJs2 = _interopRequireDefault(_uglifyJs);

var _log = require('./tools/log');

var _log2 = _interopRequireDefault(_log);

var _synchronousHttp = require('./tools/synchronous http');

var _synchronousHttp2 = _interopRequireDefault(_synchronousHttp);

var _helpers = require('./helpers');

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// using ES6 template strings
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings

var webpack_isomorphic_tools = function () {
	// require() hooks for assets

	function webpack_isomorphic_tools(options) {
		(0, _classCallCheck3.default)(this, webpack_isomorphic_tools);
		this.hooks = [];
		this.cached_assets = [];

		// take the passed in options
		this.options = (0, _helpers.convert_from_camel_case)((0, _helpers.clone)(options));

		// add missing fields, etc
		(0, _common.normalize_options)(this.options);

		// set require-hacker debug mode if run in debug mode
		if (this.options.debug) {
			_requireHacker2.default.log.options.debug = true;
		}

		// logging
		this.log = new _log2.default('webpack-isomorphic-tools', { debug: this.options.debug });

		this.log.debug('instantiated webpack-isomorphic-tools v' + require('../package.json').version + ' with options', this.options);
	}

	// sets development mode flag to whatever was passed (or true if nothing was passed)
	// (development mode allows asset hot reloading when used with webpack-dev-server)


	// used to keep track of cached assets and flush their caches on .refresh() call


	(0, _createClass3.default)(webpack_isomorphic_tools, [{
		key: 'development',
		value: function development(flag) {
			// set development mode flag
			this.options.development = (0, _helpers.exists)(flag) ? flag : true;

			if (this.options.development) {
				this.log.debug('entering development mode');
			} else {
				this.log.debug('entering production mode');
			}

			// allows method chaining
			return this;
		}

		// returns a mapping to read file paths for all the user specified asset types
		// along with a couple of predefined ones: javascripts and styles

	}, {
		key: 'assets',
		value: function assets() {
			// when in development mode
			if (this.options.development) {
				// webpack and node.js start in parallel
				// so webpack-assets.json might not exist on the very first run
				// if a developer chose not to use the .server() method with a callback
				// (or if a developer chose not to wait for a Promise returned by the .server() method)

				// either go over a network
				if (this.options.port) {
					try {
						return (0, _synchronousHttp2.default)(this.options.port);
					} catch (error) {
						this.log.error('Couldn\'t contact webpack-isomorphic-tools plugin over HTTP. Using an empty stub for webpack assets map.');
						this.log.error(error);
						return (0, _common.default_webpack_assets)();
					}
				}
				// or read it from disk
				else {
						if (!_fs2.default.existsSync(this.webpack_assets_path)) {
							this.log.error('"' + this.webpack_assets_path + '" not found. Most likely it hasn\'t yet been generated by Webpack. The most probable cause of this error is that you placed your server code outside of the callback in "webpack_isomorphic_tools.server(path, callback)" (or outside of the ".then()" call if you are using promises API). Using an empty stub instead.');
							return (0, _common.default_webpack_assets)();
						}
					}
			}

			return require(this.webpack_assets_path);
		}

		// clear the require.cache (only used in developer mode with webpack-dev-server)

	}, {
		key: 'refresh',
		value: function refresh() {
			// ensure this is development mode
			if (!this.options.development) {
				throw new Error('.refresh() called in production mode. Did you forget to call .development() method on your webpack-isomorphic-tools server instance?');
			}

			this.log.debug('flushing require() caches');

			// uncache webpack-assets.json file
			// this.log.debug(' flushing require() cache for webpack assets json file')
			// this.log.debug(` (was cached: ${typeof(require.cache[this.webpack_assets_path]) !== 'undefined'})`)
			delete require.cache[this.webpack_assets_path];

			// uncache cached assets
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = (0, _getIterator3.default)(this.cached_assets), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _path = _step.value;

					this.log.debug(' flushing require() cache for ' + _path);
					delete require.cache[_path];
				}

				// no assets are cached now
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			this.cached_assets = [];
		}

		// Makes `webpack-isomorphic-tools` aware of Webpack aliasing feature.
		// https://webpack.github.io/docs/resolving.html#aliasing
		// The `aliases` parameter corresponds to `resolve.alias`
		// in your Webpack configuration.
		// If this method is used it must be called before the `.server()` method.

	}, {
		key: 'enable_aliasing',
		value: function enable_aliasing() {
			var _this = this;

			// mount require() hook
			this.alias_hook = _requireHacker2.default.resolver(function (path, module) {
				// returns aliased global filesystem path
				return (0, _common.alias_hook)(path, module, _this.options.project_path, _this.options.alias, _this.log);
			});

			// allows method chaining
			return this;
		}

		// Initializes server-side instance of `webpack-isomorphic-tools`
		// with the base path for your project, then calls `.register()`,
		// and after that calls .wait_for_assets(callback).
		//
		// The `project_path` parameter must be identical
		// to the `context` parameter of your Webpack configuration
		// and is needed to locate `webpack-assets.json`
		//  which is output by Webpack process.
		//
		// sets up "project_path" option
		// (this option is required on the server to locate webpack-assets.json)

	}, {
		key: 'server',
		value: function server(project_path, callback) {
			var _this2 = this;

			// project base path, required to locate webpack-assets.json
			this.options.project_path = project_path;

			// resolve webpack-assets.json file path
			this.webpack_assets_path = _path3.default.resolve(this.options.project_path, this.options.webpack_assets_file_path);

			// register require() hooks
			this.register();

			// if Webpack aliases are supplied, enable aliasing
			if (this.options.alias) {
				this.enable_aliasing();
			}

			// if Webpack `modulesDirectories` are supplied, enable them
			if (this.options.modules_directories) {
				this.inject_modules_directories(this.options.modules_directories);
			}

			// inject helpers like require.context() and require.ensure()
			if (this.options.patch_require) {
				this.log.debug('Patching Node.js require() function');
				this.patch_require();
			}

			// when ready:

			// if callback is given, call it back
			if (callback) {
				// call back when ready
				return this.wait_for_assets(callback);
			}
			// otherwise resolve a Promise
			else {
					// no callback given, return a Promise
					return new _promise2.default(function (resolve, reject) {
						return _this2.wait_for_assets(resolve);
					});
				}
		}

		// Registers Node.js require() hooks for the assets
		//
		// This is what makes the `requre()` magic work on server.
		// These `require()` hooks must be set before you `require()`
		// any of your assets
		// (e.g. before you `require()` any React components
		// `require()`ing your assets).
		//
		// read this article if you don't know what a "require hook" is
		// http://bahmutov.calepin.co/hooking-into-node-loader-for-fun-and-profit.html

	}, {
		key: 'register',
		value: function register() {
			var _this3 = this;

			this.log.debug('registering require() hooks for assets');

			// // a helper array for extension matching
			// const extensions = []
			//
			// // for each user specified asset type,
			// // for each file extension,
			// // create an entry in the extension matching array
			// for (let asset_type of Object.keys(this.options.assets))
			// {
			// 	const description = this.options.assets[asset_type]
			//
			// 	for (let extension of description.extensions)
			// 	{
			// 		extensions.push([`.${extension}`, description])
			// 	}
			// }
			//
			// // registers a global require() hook which runs
			// // before the default Node.js require() logic
			// this.asset_hook = require_hacker.global_hook('webpack-asset', (path, module) =>
			// {
			// 	// for each asset file extension
			// 	for (let extension of extensions)
			// 	{
			// 		// if the require()d path has this file extension
			// 		if (ends_with(path, extension[0]))
			// 		{
			// 			// then require() it using webpack-assets.json
			// 			return this.require(require_hacker.resolve(path, module), extension[1])
			// 		}
			// 	}
			// })

			// for each user specified asset type,
			// register a require() hook for each file extension of this asset type
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(this.options.assets)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var asset_type = _step2.value;

					var description = this.options.assets[asset_type];

					var _iteratorNormalCompletion3 = true;
					var _didIteratorError3 = false;
					var _iteratorError3 = undefined;

					try {
						for (var _iterator3 = (0, _getIterator3.default)(description.extensions), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
							var extension = _step3.value;

							this.register_extension(extension, description);
						}
					} catch (err) {
						_didIteratorError3 = true;
						_iteratorError3 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion3 && _iterator3.return) {
								_iterator3.return();
							}
						} finally {
							if (_didIteratorError3) {
								throw _iteratorError3;
							}
						}
					}
				}

				// intercepts loader-powered require() paths
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			this.loaders_hook = _requireHacker2.default.global_hook('webpack-loaders', function (required_path, module) {
				// filter out non-loader paths
				// (ignore filesystem paths (both Linux and Windows)
				//  and non-loader paths)
				if ((0, _helpers.starts_with)(required_path, '/') || (0, _helpers.starts_with)(required_path, './') || (0, _helpers.starts_with)(required_path, '../') || required_path.indexOf(':') > 0 || required_path.indexOf('!') < 0) {
					return;
				}

				var parts = required_path.split('!');
				var local_asset_path = parts.pop();

				// extra measures taken here to not
				// confuse some legit require()d path
				// with a seemingly loader-powered one
				if (!(0, _helpers.starts_with)(local_asset_path, './') && !(0, _helpers.starts_with)(local_asset_path, '../')) {
					return;
				}

				parts = parts.map(function (loader) {
					var loader_parts = loader.split('?');

					if (!(0, _helpers.ends_with)(loader_parts[0], '-loader')) {
						loader_parts[0] += '-loader';
					}

					return './~/' + loader_parts.join('?');
				});

				var global_asset_path = _requireHacker2.default.resolve(local_asset_path, module);

				var path = parts.join('!') + '!' + _this3.normalize_asset_path(global_asset_path);

				var asset = _this3.asset_source(path);

				if (asset === undefined) {
					return;
				}

				return _this3.require_asset(asset, { require_cache_path: required_path + '.webpack-loaders' });
			});

			// allows method chaining
			return this;
		}

		// registers a require hook for a particular file extension

	}, {
		key: 'register_extension',
		value: function register_extension(extension, description) {
			var _this4 = this;

			this.log.debug(' registering a require() hook for *.' + extension);

			// place the require() hook for this extension
			if (extension === 'json') {
				this.hooks.push(_requireHacker2.default.hook(extension, function (path) {
					// special case for require('webpack-assets.json') and 'json' asset extension
					if (path === _this4.webpack_assets_path) {
						return;
					}

					return _this4.require(path, description);
				}));
			} else {
				this.hooks.push(_requireHacker2.default.hook(extension, function (path) {
					return _this4.require(path, description);
				}));
			}
		}

		// injects Webpack's `modulesDirectories` into Node.js module resolver

	}, {
		key: 'inject_modules_directories',
		value: function inject_modules_directories(modules_directories) {
			modules_directories = modules_directories.filter(function (x) {
				return x !== 'node_modules';
			});

			// instrument Module._nodeModulePaths function
			// https://github.com/nodejs/node/blob/master/lib/module.js#L202
			//
			var original_find_paths = require('module')._findPath;
			//
			require('module')._findPath = function (request, paths) {
				paths.map(function (a_path) {
					var parts = a_path.split(_path3.default.sep);
					if (parts[parts.length - 1] === 'node_modules') {
						parts[parts.length - 1] = '';
						return parts.join(_path3.default.sep);
					}
				}).filter(function (a_path) {
					return a_path;
				}).forEach(function (a_path) {
					modules_directories.forEach(function (modules_directory) {
						paths.push(a_path + modules_directory);
					});
				});

				return original_find_paths(request, paths);
			};
		}

		// injects helper functions into `require()` function
		// (such as `.context()` and `.ensure()`)
		// https://github.com/halt-hammerzeit/webpack-isomorphic-tools/issues/48#issuecomment-182878437
		// (this is a "dirty" way to do it but it works)

	}, {
		key: 'patch_require',
		value: function patch_require() {
			// a source code of a function that
			// require()s all modules inside the `base` folder
			// and puts them into a hash map for further reference
			//
			// https://webpack.github.io/docs/context.html
			//
			var require_context = 'require.context = function(base, scan_subdirectories, regular_expression)\n\t\t{\n\t\t\tbase = require(\'path\').join(require(\'path\').dirname(module.filename), base)\n\n\t\t\tvar contents = {}\n\n\t\t\t// recursive function\n\t\t\tfunction read_directory(directory)\n\t\t\t{\n\t\t\t\trequire(\'fs\').readdirSync(directory).forEach(function(child)\n\t\t\t\t{\n\t\t\t\t\tvar full_path = require(\'path\').resolve(directory, child)\n\n\t\t\t\t\tif (require(\'fs\').statSync(full_path).isDirectory())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (scan_subdirectories)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tread_directory(full_path)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar asset_path = require(\'path\').relative(base, full_path)\n\n\t\t\t\t\t\t// analogous to "uniform_path" from "./common.js"\n\t\t\t\t\t\tasset_path = (asset_path[0] === \'.\' ? asset_path : (\'./\' + asset_path)).replace(/\\\\/g, \'/\')\n\n\t\t\t\t\t\tif (regular_expression && !regular_expression.test(asset_path))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontents[asset_path] = full_path\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tread_directory(base)\n\n\t\t\tvar result = function(asset_path)\n\t\t\t{\n\t\t\t\treturn require(contents[asset_path])\n\t\t\t}\n\n\t\t\tresult.keys = function()\n\t\t\t{\n\t\t\t\treturn Object.keys(contents)\n\t\t\t}\n\n\t\t\tresult.resolve = function(asset_path)\n\t\t\t{\n\t\t\t\treturn contents[asset_path]\n\t\t\t}\n\n\t\t\treturn result\n\t\t};';

			// some code minification
			require_context = _uglifyJs2.default.minify(require_context, { fromString: true }).code;

			// Source code for `require.ensure()`
			// https://github.com/halt-hammerzeit/webpack-isomorphic-tools/issues/84
			var require_ensure = 'require.ensure=function(d,c){c(require)};';

			var debug = this.log.debug.bind(this.log);

			// instrument Module.prototype._compile function
			// https://github.com/nodejs/node/blob/master/lib/module.js#L376-L380
			//
			var original_compile = require('module').prototype._compile;
			//
			require('module').prototype._compile = function (content, filename) {
				// inject it only in .js files
				if (!(0, _helpers.ends_with)(filename, '.js')) {
					// (the return value is supposed to be `undefined`)
					return original_compile.call(this, content, filename);
				}

				// will be prepended to the module source code
				var preamble = '';

				// inject it only in .js files which
				// might probably have `require.context` reference
				if (content.indexOf('require.context') >= 0) {
					debug('Injecting require.context() into "' + filename + '"');
					preamble += require_context;
				}

				// inject it only in .js files which
				// might probably have `require.ensure` reference
				if (content.indexOf('require.ensure') >= 0) {
					debug('Injecting require.ensure() into "' + filename + '"');
					preamble += require_ensure;
				}

				// If there is a preamble to prepend
				if (preamble) {
					// Account for "use strict" which is required to be in the beginning of the source code
					if ((0, _helpers.starts_with)(content, '\'use strict\'') || (0, _helpers.starts_with)(content, '"use strict"')) {
						preamble = '"use strict";' + preamble;
					}
				}

				// the "dirty" way
				content = preamble + content;

				// (the return value is supposed to be `undefined`)
				return original_compile.call(this, content, filename);
			};
		}
	}, {
		key: 'normalize_asset_path',
		value: function normalize_asset_path(global_asset_path) {
			// sanity check
			/* istanbul ignore if */
			if (!this.options.project_path) {
				throw new Error('You forgot to call the .server() method passing it your project\'s base path');
			}

			// convert global asset path to local-to-the-project asset path
			return (0, _common.normalize_asset_path)(global_asset_path, this.options.project_path);
		}

		// require()s an asset by a global path

	}, {
		key: 'require',
		value: function require(global_asset_path, description) {
			this.log.debug('require() called for ' + global_asset_path);

			// convert global asset path to local-to-the-project asset path
			var asset_path = this.normalize_asset_path(global_asset_path);

			// if this filename is in the user specified exceptions list
			// (or is not in the user explicitly specified inclusion list)
			// then fall back to the normal require() behaviour
			if (!this.includes(asset_path, description) || this.excludes(asset_path, description)) {
				this.log.debug(' skipping require call for ' + asset_path);
				return;
			}

			// find this asset in the list
			var asset = this.asset_source(asset_path);

			// if the asset was not found in the list, output an error
			if (asset === undefined) {
				this.log.error('asset not found: ' + asset_path);
			}

			return this.require_asset(asset, { require_cache_path: global_asset_path });
		}

		// require()s an asset by it source

	}, {
		key: 'require_asset',
		value: function require_asset(asset, options) {
			// this.log.debug(`require() called for ${asset_path}`)

			// track cached assets (only in development mode)
			if (this.options.development) {
				// mark this asset as cached
				this.cached_assets.push(options.require_cache_path);
			}

			// return CommonJS module source for this asset
			return _requireHacker2.default.to_javascript_module_source(asset);
		}

		// returns asset source by path (looks it up in webpack-assets.json)

	}, {
		key: 'asset_source',
		value: function asset_source(asset_path) {
			this.log.debug(' requiring ' + asset_path);

			// Webpack replaces `node_modules` with `~`.
			// I don't know how exactly it decides whether to
			// replace `node_modules` with `~` or not
			// so it will be a guess.
			function possible_webpack_paths(asset_path) {
				// Webpack always replaces project's own `node_modules` with `~`
				if ((0, _helpers.starts_with)(asset_path, './node_modules/')) {
					asset_path = asset_path.replace('./node_modules/', './~/');
				}

				// if there are any `node_modules` left,
				// supposing the count is N,
				// then there are 2 to the power of N possible guesses
				// on how webpack path might look like.
				var parts = asset_path.split('/node_modules/');

				function construct_guesses(parts) {
					if (parts.length === 1) {
						return [parts];
					}

					var last = parts.pop();
					var rest = construct_guesses(parts);

					var guesses = [];

					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = (0, _getIterator3.default)(rest), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var guess = _step4.value;

							var one = (0, _helpers.clone)(guess);
							one.push('/~/');
							one.push(last);

							var two = (0, _helpers.clone)(guess);
							two.push('/node_modules/');
							two.push(last);

							guesses.push(one);
							guesses.push(two);
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}

					return guesses;
				}

				return construct_guesses(parts);
			}

			// get real file path list
			var assets = this.assets().assets;

			var possible_webpack_asset_paths = possible_webpack_paths(asset_path).map(function (path) {
				return path.join('');
			});

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = (0, _getIterator3.default)(possible_webpack_asset_paths), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var webpack_asset_path = _step5.value;

					if (possible_webpack_asset_paths.length > 1) {
						this.log.debug('  trying "' + webpack_asset_path + '"');
					}

					// find this asset in the real file path list
					var asset = assets[webpack_asset_path];

					if ((0, _helpers.exists)(asset)) {
						// the asset was found in the list - return it
						return asset;
					}
				}

				// if the asset was not found in the list, return nothing
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			return;
		}

		// unregisters require() hooks

	}, {
		key: 'undo',
		value: function undo() {
			// for each user specified asset type,
			// unregister a require() hook for each file extension of this asset type
			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = (0, _getIterator3.default)(this.hooks), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					var hook = _step6.value;

					hook.unmount();
				}

				// this.asset_hook.unmount()

				// unmount the aliasing hook (if mounted)
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 && _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}

			if (this.alias_hook) {
				this.alias_hook.unmount();
			}

			// unmount require() hook which intercepts loader-powered require() paths
			if (this.loaders_hook) {
				this.loaders_hook.unmount();
			}
		}

		// Checks if the required path should be excluded from the custom require() hook

	}, {
		key: 'excludes',
		value: function excludes(path, options) {
			// if "exclude" parameter isn't specified, then exclude nothing
			if (!(0, _helpers.exists)(options.exclude)) {
				return false;
			}

			// for each exclusion case
			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = (0, _getIterator3.default)(options.exclude), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var exclude = _step7.value;

					// supports regular expressions
					if (exclude instanceof RegExp) {
						if (exclude.test(path)) {
							return true;
						}
					}
					// check for a compex logic match
					else if (typeof exclude === 'function') {
							if (exclude(path)) {
								return true;
							}
						}
						// otherwise check for a simple textual match
						else {
								if (exclude === path) {
									return true;
								}
							}
				}

				// no matches found.
				// returns false so that it isn't undefined (for testing purpose)
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			return false;
		}

		// Checks if the required path should be included in the custom require() hook

	}, {
		key: 'includes',
		value: function includes(path, options) {
			// if "include" parameter isn't specified, then include everything
			if (!(0, _helpers.exists)(options.include)) {
				return true;
			}

			// for each inclusion case
			var _iteratorNormalCompletion8 = true;
			var _didIteratorError8 = false;
			var _iteratorError8 = undefined;

			try {
				for (var _iterator8 = (0, _getIterator3.default)(options.include), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
					var include = _step8.value;

					// supports regular expressions
					if (include instanceof RegExp) {
						if (include.test(path)) {
							return true;
						}
					}
					// check for a compex logic match
					else if (typeof include === 'function') {
							if (include(path)) {
								return true;
							}
						}
						// otherwise check for a simple textual match
						else {
								if (include === path) {
									return true;
								}
							}
				}

				// no matches found.
				// returns false so that it isn't undefined (for testing purpose)
			} catch (err) {
				_didIteratorError8 = true;
				_iteratorError8 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion8 && _iterator8.return) {
						_iterator8.return();
					}
				} finally {
					if (_didIteratorError8) {
						throw _iteratorError8;
					}
				}
			}

			return false;
		}

		// Waits for webpack-assets.json to be created after Webpack build process finishes
		//
		// The callback is called when `webpack-assets.json` has been found
		// (it's needed for development because `webpack-dev-server`
		//  and your application server are usually run in parallel).
		//

	}, {
		key: 'wait_for_assets',
		value: function wait_for_assets(done) {
			var _this5 = this;

			// condition check interval
			var check_interval = 300; // in milliseconds
			var message_interval = 2000; // in milliseconds

			// show the message not too often
			var message_timer = 0;

			// selfie
			var tools = this;

			// waits for condition to be met, then proceeds
			function wait_for(condition, proceed) {
				function check() {
					// if the condition is met, then proceed
					if (condition()) {
						return proceed();
					}

					message_timer += check_interval;

					if (message_timer >= message_interval) {
						message_timer = 0;

						tools.log.debug('(' + tools.webpack_assets_path + ' not found)');
						tools.log.info('(waiting for the first Webpack build to finish)');
					}

					setTimeout(check, check_interval);
				}

				check();
			}

			// wait for webpack-assets.json to be written to disk by Webpack
			// (setTimeout() for global.webpack_isomorphic_tools )

			var ready_check = void 0;

			// either go over network
			if (this.options.development && this.options.port) {
				ready_check = function ready_check() {
					try {
						(0, _synchronousHttp2.default)(_this5.options.port);
						return true;
					} catch (error) {
						if (!(0, _helpers.starts_with)(error.message, 'Server responded with status code 404:\nWebpack assets not generated yet') && !(0, _helpers.starts_with)(error.message, 'connect ECONNREFUSED') && !(0, _helpers.starts_with)(error.message, 'Request timed out after')) {
							_this5.log.error('Couldn\'t contact webpack-isomorphic-tools plugin over HTTP. Using an empty stub for webpack assets map.');
							_this5.log.error(error);
						}

						return false;
					}
				};
			}
			// or read it from disk
			else {
					ready_check = function ready_check() {
						return _fs2.default.existsSync(_this5.webpack_assets_path);
					};
				}

			(0, _setImmediate3.default)(function () {
				return wait_for(ready_check, done);
			});

			// allows method chaining
			return this;
		}
	}]);
	return webpack_isomorphic_tools;
}();

// Doesn't work with Babel 6 compiler
// // alias camel case for those who prefer it
// alias_properties_with_camel_case(webpack_isomorphic_tools.prototype)


exports.default = webpack_isomorphic_tools;
module.exports = exports['default'];
//# sourceMappingURL=index.js.map